* About
The goal of pyems is to provide a convenient interface to [[https://openems.de/start/index.php][OpenEMS]] that
is as flexible as OpenEMS's own Python interface. The initial
motivation for this package was to allow automatic mesh generation
(which is supported, although in early stages). However, this also
opens up a number of possibilites for new functionality that is
impossible when the mesh is generated manually. For instance, we can
perform parameter sweeps, or, similarly, find the optimal value of a
parameter given some other target value.

I also intend to write a number of complete simulations for common
calculations. For instance, a user can call a function and get back
the optimal microstrip trace width for a desired characteristic
impedance. These simulations will be parameterizable so that they can
be tailored for the specific use case. In the previous example, the
user would need to pass several parameters for frequency range, PCB
height, trace height, dielectric, etc. These simulations are located
in the pyems/sims directory, which also serves as the examples
directory for new users hoping to learn pyems's API.

* Usage
Note: the interface to pyems is changing rapidly. The usage section
may be out of date.

For working examples, see the examples/ and pyems/sims/ directories.

The general way to run a simulation is via the following steps:

Create ~openEMS()~ and ~ContinuousStructure()~ objects. This is how
pyems connects up to openems. e.g.

#+begin_src python
import os
import numpy as np
import matplotlib.pyplot as plt
import CSXCAD as csxcad
import openEMS as openems
from pyems.network import Network
from pyems.utilities import wavelength, array_index
from pyems.port import RectWaveguidePort, standard_waveguides
from pyems.simulation import Simulation
from pyems.field_dump import FieldDump

fdtd = openems.openEMS(EndCriteria=1e-5)
csx = csxcad.ContinuousStructure()

# optionally, set the length unit for all further dimensions
# this uses mm (default is m)
unit = 1e-3
csx.GetGrid().SetDeltaUnit(unit)
#+end_src

Create your ports. Ports are meant to be just like the ports you might
connect up to a VNA. They function as the interface to the device
you're testing and are used to calculate S-parameters.

#+begin_src python
wg = standard_waveguides["WR159"]
wg_len = 40 * unit
waveguide_box = np.multiply(
    1 / unit,
    [[-wg["a"] / 2, -wg["b"] / 2, -wg_len], [wg["a"] / 2, wg["b"] / 2, 0]],
)
port = RectWaveguidePort(
    csx=csx, box=waveguide_box, propagation_axis=2, excite=True
)
port.add_metal_shell(thickness=5)
#+end_src

Add any other structures you like

#+begin_src python
metal = csx.AddMetal("metal")
stl = metal.AddPolyhedronReader(filename=os.path.abspath("./horn-antenna.stl"))
stl.ReadFile()
#+end_src

Instantiate a network from the ports. A network is like an electrical
network. It serves as a convenient wrapper for a collection of ports,
which allows you to calculate S-parameters from port numbers, rather
than needing to get the data from the ports and do the calculations
yourself. Make sure to place the ports in the order you'd like them
numbered.

#+begin_src python
center_freq = 5.6e9
delta_freq = 5e9
network = Network(csx=csx, ports=[port])
network.generate_mesh(
    min_wavelength=wavelength(center_freq + delta_freq, unit),
    metal_res=1 / 40,
    min_lines=2,
    expand_bounds=[20, 20, 20, 20, 10, 40],
)
network._write_csx()
network.view()
#+end_src

Add any field dumps for viewing the time-domain data after the
simulation completes.

#+begin_src python
sim_box = network.get_sim_box()
field_dump = FieldDump(csx=csx, box=sim_box)
#+end_src

Generate the mesh and optionally view the structure.

#+begin_src python
network.generate_mesh(
    min_wavelength=wavelength(center_freq + delta_freq, unit),
    min_lines=2,
    expand_bounds=[20, 20, 20, 20, 10, 40],
)
network.view()
#+end_src

Create a simulation object. This is ties together all parts of the
simulation and is the interface used for post-processing and
viewing/printing results.

#+begin_src python
sim = Simulation(
    fdtd=fdtd,
    csx=csx,
    center_freq=center_freq,
    half_bandwidth=delta_freq,
    boundary_conditions=["PML_8", "PML_8", "PML_8", "PML_8", "PML_8", "PML_8"],
    network=network,
    field_dumps=[field_dump],
)
#+end_src

Simulate.

#+begin_src python
sim.simulate(nf2ff=True)
#+end_src

When the simulation completes, you can retreive/print/view the results
in a variety of ways.

#+begin_src python
# view the time-domain E-field dumps.
sim.view_field()

s11 = network.s_param(1, 1)
ports = network.get_ports()
freq = sim.get_freq()

# plot return loss
plt.figure()
plt.plot(freq, s11)
plt.show()

theta = np.arange(-90, 90, 1)
phi = np.arange(0, 360, 1)

# perform a near-to-far field transformation
nf2ff = sim.calc_nf2ff(theta=theta, phi=phi)

horn_width = 109.9 * 1e-3
horn_height = 80 * 1e-3
effective_aperture = horn_height * horn_width
directivity = (
    effective_aperture * 4 * np.pi / np.power(wavelength(center_freq, 1), 2)
)
gain = nf2ff.Dmax[0]
gain_db = 10 * np.log10(gain)

freq_array = sim.get_freq()
print("gain:\t\t{:.2f} dB".format(gain_db))

enorm = nf2ff.E_norm[0]
phi90_idx = array_index(90, phi)

# plot the gain as a function of angle
plt.plot(theta, 20 * np.log10(enorm[:, 0] / np.amax(enorm[:, 0])) + gain_db)
plt.show()
plt.plot(
    theta,
    20 * np.log10(enorm[:, phi90_idx] / np.amax(enorm[:, phi90_idx]))
    + gain_db,
)
plt.show()
#+end_src

This process is very similar to how you would do it using OpenEMS's
native interface. The biggest difference is that you no longer need to
worry about mesh generation and you don't need to worry about when
ports are generated in relation to when the mesh is generated. Port
placement is automatically adjusted for the generated mesh.

More generally, I've tried to design the interface in a way that
directs the process of creating/running a simulation and makes it easy
to retrieve useful results. For instance, instead of doing

#+begin_src python
s12 = port1.uf.ref ./ port2.uf.inc
#+end_src

you would write

#+begin_src python
s12 = sim.get_network().s_param(1, 2)
#+end_src

It's not that the first way is particularly challenging, but it
requires you to know that OpenEMS ports store their voltage frequency
values as ~uf~ and the incident and reflected waves as ~inc~ and
~ref~.

* To-Do
** TODO probe should not hold onto freq
** TODO probe get_freq_data and get_time_data
These methods are poorly named. freq_data and time_data are better
names. Additionally, they shouldn't pass back frequency and time
values. This should be retreived with other methods. Note that this
will require adjustments to port.py too.

** TODO microstrip propagation should be able to be set
This would allow y-direction propagation in addition to x. This would
allow less-expensive simulations for things like bends.

** TODO floating point precision errors
Zero-dimension structures can easily be ignored because of floating
point value changes. I think the solution is to set a precision (for
instance see the mesh.py file). However, I'm still getting some
ignored structures. Maybe I also need to do this when adding
structures?

** TODO rectwaveguideport propagation axis
This should use the Axis object.

** TODO port calc requires self._propagation_axis set
self._propagation_axis is not currently required for the port base
class. The interface must be changed in some way that is also
compatible with the derived classes.

** HOLD mesh should support primitive priorities
** HOLD mesh option to ignore very small structures
This is useful when your model inadvertently creates tiny structures
(i.e. two overlapping objects are almost the same size) that would
increase the simulation time dramatically. To not screw up mesh
generation, this will need to merge these BoundedType's with the
adjacent (smallest?) BoundedType.
